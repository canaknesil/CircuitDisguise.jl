# Workflow

This page describes the Circuit Disguise workflow on an example design. The workflow steps are as follows:

- [Generate netlist](@ref)
- [Convert netlist](@ref)
- [Read netlist](@ref)
- [Disguise netlist](@ref)
- [Save/load design](@ref)
- [Design checks](@ref)

## Generate netlist

The starting point of the workflow is a netlist of a compiled
design. CircuitDisguise.jl is tested with netlists generated by Xilinx
Vivado design suite.

CircuitDisguise.jl accepts a netlist that consists of two files: 

- `netlist.v`: Verilog netlist file
- `delays.sdf`: Standard Delay Format (SDF) that contains associated delay information

These two files can be generated in Vivado Tcl environment with the
following commands:

```Tcl
# Generate the design netlist
write_verilog -mode design /path/to/design/netlist.v

# Generate timing delays
write_sdf /path/to/design/delays.sdf
```

From here on, all functionality is available through
CircuitDisguise.jl. The examples below assume that the current working
directory is the repository's top directory.


## Convert netlist

Before the disguise, a netlist should be converted to a format more
suitable for CircuitDisguise.jl using [`convert_netlist`](@ref). This
step requires Yosys to be installed and available in PATH.

We will convert an example design, a single AND gate, located at
`simple-designs/and_gate`.


Start Julia REPL.

```
$ julia --project
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.9.2 (2023-07-05)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |

julia>
```

Import the `CircuitDisguise` module.
```@repl 1
using CircuitDisguise
```

Run [`convert_netlist`](@ref) as follows:

```
julia> convert_netlist("simple-designs/and_gate/outputs_vivado_xilinx_7/", "vivado", "xilinx_7")
Converting netlist at simple-designs/and_gate/outputs_vivado_xilinx_7/ ...
Running Yosys commands: read -sv simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.v; hierarchy -auto-top; flatten; techmap -map /home/canaknesil/Documents/repos/circuit-disguise/src/../netlist-preparation/cell_map_xilinx_7.v; write_rtlil simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.rtlil; write_json simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.json

 /----------------------------------------------------------------------------\
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |  Copyright (C) 2012 - 2024  Claire Xenia Wolf <claire@yosyshq.com>         |
 |  Distributed under an ISC-like license, type "license" to see terms        |
 \----------------------------------------------------------------------------/
 Yosys 0.39 (git sha1 00338082b00, g++ 9.4.0-1ubuntu1~20.04.2 -fPIC -Os)

-- Running command `read -sv simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.v; hierarchy -auto-top; flatten; techmap -map /home/canaknesil/Documents/repos/circuit-disguise/src/../netlist-preparation/cell_map_xilinx_7.v; write_rtlil simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.rtlil; write_json simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.json' --

1. Executing Verilog-2005 frontend: simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.v
Parsing SystemVerilog input from `simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.v' to AST representation.
Storing AST representation for module `$abstract\circuit_disguise_top'.
Successfully finished Verilog frontend.

2. Executing HIERARCHY pass (managing design hierarchy).

2.1. Executing AST frontend in derive mode using pre-parsed AST for module `\circuit_disguise_top'.
Generating RTLIL representation for module `\circuit_disguise_top'.

2.2. Finding top of design hierarchy..
root of   0 design levels: circuit_disguise_top
Automatically selected circuit_disguise_top as design top module.

2.3. Analyzing design hierarchy..
Top module:  \circuit_disguise_top

2.4. Analyzing design hierarchy..
Top module:  \circuit_disguise_top
Removed 0 unused modules.

3. Executing FLATTEN pass (flatten design).

4. Executing TECHMAP pass (map to technology primitives).

4.1. Executing Verilog-2005 frontend: /home/canaknesil/Documents/repos/circuit-disguise/src/../netlist-preparation/cell_map_xilinx_7.v
Parsing Verilog input from `/home/canaknesil/Documents/repos/circuit-disguise/src/../netlist-preparation/cell_map_xilinx_7.v' to AST representation.
Generating RTLIL representation for module `\LUT6_2'.
Successfully finished Verilog frontend.

4.2. Continuing TECHMAP pass.
Cell type mappings to use:
    LUT6_2: LUT6_2

No more expansions possible.

5. Executing RTLIL backend.
Output filename: simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.rtlil

6. Executing JSON backend.

End of script. Logfile hash: 19bd39bd27, CPU: user 0.00s system 0.00s, MEM: 298.76 MB peak
Yosys 0.39 (git sha1 00338082b00, g++ 9.4.0-1ubuntu1~20.04.2 -fPIC -Os)
Time spent: 50% 3x read_verilog (0 sec), 16% 2x write_rtlil (0 sec), ...

Converting netlist at simple-designs/and_gate/outputs_vivado_xilinx_7/ DONE.
true
```

The Boolean return value, printed in the last line of the REPL output,
tells weather the conversion was successful.

After the execution, `netlist.json` should appear next to `netlist.v`.

The conversion can optionally be performed without
`CircuitDisguise.jl`, using the script `src/convert-netlist.jl`. This
may be useful when converting netlists to be used in tests, during
which the project may be broken.

```
$ julia src/convert-netlist.jl <design-tool> <cell-library> <top-module> <netlist-directory> ...
```

## Read netlist

Read netlist with [`read_netlist`](@ref). 

[`read_netlist`](@ref) takes as input the netlist converted into a
JSON file, the SDF delays file, and the name of the cell library. A
cell library contains information about available FPGA resources. The
selection of the cell library depends on the target FPGA for which the
design was compiled. The example design was compiled for a Xilinx
7-series FPGA. 

[`read_netlist`](@ref) returns a [`DesignNetlist`](@ref) object and a
[`CellLibrary`](@ref) object.

A netlist is internally stored as a directed graph, of type
[`Graph`](@ref), where primary I/O and cell ports are represented by
vertices, of type [`Vertex`](@ref), wires and IO paths are represented
by edges, of type [`Edge`](@ref). A netlist (before disguise), in
addition to the graph, also contains a list of cells, of type
[`Cell`](@ref), each pointing to its ports.

```@repl 1
netlist, lib = read_netlist(
	netlist_fname_json = "simple-designs/and_gate/outputs_vivado_xilinx_7/netlist.json",
	delays_fname_sdf = "simple-designs/and_gate/outputs_vivado_xilinx_7/delays.sdf",
	cell_library = "xilinx_7"
);
netlist
```

## Disguise netlist

Disguise netlist using [`disguise_design!`](@ref).

[`disguise_design!`](@ref) takes a netlist and a cell library as
input, and returns a disguised design of type
[`DisguisedDesign`](@ref). 

The netlist is modified with new information calculated during the
disguise. This is the reason the function name ends with `!` as a
Julia convention.

```@repl 1
disguised_design = disguise_design!(netlist, lib)
```

## Save/load design

A design, before or after the disguise, can be saved or loaded using
[`save_design`](@ref) and [`load_design`](@ref), respectively. This
functionality can be used to transfer a design to another party.

## Design checks

A disguised design can be checked for various malicious circuits.

### Check for combinational cycles 

Check a design for combinational cycles with [`check_cycles`](@ref).

```@repl 1
cycle_report = check_cycles(disguised_design)
```

### Check for excessive fan-out

Check a design for excessive fan-out with [`check_fanout`](@ref).

```@repl 1
fanout_report = check_fanout(
	disguised_design,
	max_fanout_threshold = 50
)
```

### Check for bad connections

Check for data-to-clock and data-to-asynchronous signal connections
with [`check_signal_connections`](@ref).

```@repl 1
signal_connection_report = check_signal_connections(disguised_design)
```

### Check for short circuits

Check for short circuits with [`check_short_circuits`](@ref).

```@repl 1
short_circuit_report = check_short_circuits(disguised_design)
```

### Check for excessive power consumption

Check for excessive dynamic power consumption with [`check_power`](@ref).

Power check requires a load capacitance value associated to every
wire. In the ideal case, load capacitances should be available in the
netlist. But, they can be alternatively inferred from wire delays,
which we do by setting `load_capacitance_source` keyword argument to
`"from_delay"`.

Inference of load capacitances from delays requires a delay to be
associated to every primary port, which can be done with
[`set_primary_port_delay!`](@ref), or alternatively with [`set_delay!`](@ref).

```@repl 1
set_primary_port_delay!(disguised_design, 0)
```

Power check also requires a frequency value associated to every
edge. This can be done by propagating the frequencies through the
design, with [`propagate_frequency!`](@ref), which has an option for
setting frequency of all primary inputs. Optionally, individual
frequencies can be set with [`set_primary_input_frequency!`](@ref), or
alternatively with [`set_frequency!`](@ref), before the propagation.

```@repl 1
propagate_frequency!(disguised_design, primary_input_freq=500e6)
power_report = check_power(
	disguised_design,
	load_capacitance_source = "from_delay",
	total_dynamic_power_threshold = 1000
)
```

### Check for timing violations

Check for setup and hold violations with [`check_timing!`](@ref).

Timing analysis requires a delay associated to every primary port,
which can be done with [`set_primary_port_delay!`](@ref), or
alternatively with [`set_delay!`](@ref). We already associated delays
before the power check.

Detecting setup violations requires a frequency associated to every
clock source. Individual clock frequencies can be set using
[`set_primary_input_frequency!`](@ref), or alternatively with
[`set_frequency!`](@ref), and propagated with
[`propagate_frequency!`](@ref).

As our current example design `simple-designs/and_gate` doesn't have
any clock signal, we demonstrate timing check on another example,
`simple-designs/counter`, which has one clock signal provided through
a primary input.

```@repl 2
using CircuitDisguise # hide
netlist, lib = read_netlist(
	netlist_fname_json = "simple-designs/counter/outputs_vivado_xilinx_7/netlist.json",
	delays_fname_sdf = "simple-designs/counter/outputs_vivado_xilinx_7/delays.sdf",
	cell_library = "xilinx_7"
);
disguised_design = disguise_design!(netlist, lib);
set_primary_port_delay!(disguised_design, 0)
set_primary_input_frequency!(disguised_design, Dict("clk" => 100e6))
propagate_frequency!(disguised_design, primary_input_freq=500e6)
timing_report = check_timing!(disguised_design)
```


### Perform all design checks at once

All the design checks listed above can be executed in one go with
[`check_design!`](@ref).

```@repl 3
using CircuitDisguise # hide
netlist, lib = read_netlist(
	netlist_fname_json = "simple-designs/counter/outputs_vivado_xilinx_7/netlist.json",
	delays_fname_sdf = "simple-designs/counter/outputs_vivado_xilinx_7/delays.sdf",
	cell_library = "xilinx_7"
);
disguised_design = disguise_design!(netlist, lib);
set_primary_port_delay!(disguised_design, 0)
propagate_frequency!(disguised_design, primary_input_freq=500e6)
reports = check_design!(
	disguised_design,
	primary_port_delay = 0,
	primary_input_freq = 500e6,
	max_fanout_threshold = 50,
	total_dynamic_power_threshold = 1000
);
for r in reports
	print_status(r)
end
```


